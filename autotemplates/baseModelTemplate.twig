<?php

/**
 * This is the base model class for the database table '{{ tablename }}'
 *
 * Do not modify this file, it is overwritten via the db2model script
 * If any changes are required, override them in the '{{ namespace }}\{{ modelname }}' class.
 */

namespace {{ namespace }};

/**
{% for field in structure %}
 * @property {{ field.doctype }} ${{ field.name }}
{% if (field.type == 'json' or field.type == 'serialize') %}
 * @property array ${{ field.name }}_decoded
{% endif %}
{% if (field.type == 'dob') or (field.type == 'date') or (field.type == 'datetime') or (field.type == 'time') %}
 * @property \Cake\Chronos\Chronos ${{ field.name }}_chronos
{% endif %}
{% endfor %}
{% for field in belongsTo %}
 * @property \{{ field.namespace }}\{{ field.modelname }} ${{ field.arvarname }}
{% endfor %}
{% for field in hasMany %}
 * @property \{{ field.namespace }}\{{ field.modelname }}[] ${{ field.arvarname }}
{% endfor %}
 *
 * @method \{{ namespace }}\{{ modelname }} save(boolean $ignore = false) Save and reload the model, optionally ignoring existing id (Use INSERT ON DUPLICATE KEY UPDATE query).
 */
abstract class Base{{ modelname }} extends {{ modelToExtend }} {
    public static $_table = '{{ tablename }}';

	/**
	 * Starting point for all queries
	 * @return \{{ namespace }}\Query{{ modelname }}
	 */
	public static function model() {
		return \Granada\Granada::factory('{{ namespace }}\{{ modelname }}');
	}

{% for field in belongsTo %}
    public function {{ field.arvarname }}() {
        return $this->belongs_to('{{ field.namespace }}\{{ field.modelname }}', '{{ field.varname }}');
    }

{% endfor %}
{% for field in hasMany %}
    public function {{ field.arvarname }}() {
        return $this->has_many('{{ field.namespace }}\{{ field.modelname }}', '{{ field.varname }}')->defaultFilter()->order_by_expr(\{{ field.namespace }}\{{ field.modelname }}::defaultOrder());
    }

    /**
     * Get the field name of the {{ field.modelname }} that links back to this {{ modelname }}
     * @return string
     */
    public function {{ field.arvarname }}_refVar() {
            return '{{ field.varname }}';
    }

{% endfor %}
	/**
	 * @return string The current namespace
	 */
	public function getNamespace() {
		return '{{ namespace }}';
	}

	/**
	 * @return string The current model name
	 */
	public function getModelname() {
		return '{{ modelname }}';
	}

	/**
	 * Get the type of variable for the field
	 * @var string $field_name
	 * @return string
	 */
	public function fieldType($field_name) {
		$fields = array(
{% for field in structure %}
		'{{ field.name }}' => '{{ field.type }}',
{% endfor %}
		);
		if (!array_key_exists($field_name, $fields)) {
			return false;
		}
		return $fields[$field_name];
	}

	/**
	 * Get the database table name
	 *
	 * @return string Table name
	 */
	public function tableName() {
		return '{{ tablename }}';
	}

	/**
	 * Get the human-readable name for the model
	 *
	 * @return string
	 */
	public static function humanName() {
		return '{{ humanName }}';
	}

	/**
	 * Get the plural version of human-readable name for the model
	 *
	 * @return string
	 */
	public static function humanNames() {
		return \Granada\Builder\Autobuild::pluralize('{{ humanName }}');
	}

	/**
	 * The columns used as part of the representation method
	 */
	public static function uniqueColumns() {
		return array(
{% for field in structure %}
{% if field.unique %}
			'{{ field.name }}',
{% endif %}
{% endfor %}
		);
	}

	/**
	 * Is this model a nestedSet ?
	 * @return boolean
	 */
	public static function isNestedSet() {
{% if nestedSet %}
		return true;
{% else %}
		return false;
{% endif %}
	}

	/**
	 * The column used as the main identifier for the model
	 * @return string
	 */
	public static function defaultOrder() {
{% if nestedSet %}
		return 'root,lft';
{% else %}
		return '{{ defaultorder }}';
{% endif %}
	}

	/**
	 * The column used as the main identifier for the model
	 */
	public static function primaryColumn() {
		return '{{ representation }}';
	}

	/**
	 * The value of the main identifier for the model
	 */
	public function representation() {
		return $this->{{ representation }};
	}

    /**
     * The columns used as part of the representation method
     */
    public static function representationColumns() {
            return array('{{ representation }}');
    }

	/**
	 * Any fields listed in this array will not affect the updated_at and created_at timestamp fields on save
	 * Override to ignore more
	 */
	public function ignoreDirtyForTimestamps() {
		return array(
			'sort_order',
		);
	}

	/**
	 * Check that the model has a field name
	 *
	 * @var string $field
	 * @return boolean
	 */
	public static function hasAttribute($field) {
		return array_key_exists($field, self::attributes());
	}

	/**
	 * List of fields in the model
	 *
	 * @return string[]
	 */
	public static function attributes() {
		return array(
{% for field in structure %}
			'{{ field.name }}' => '{{ field.name }}',
{% endfor %}
		);
	}

	/**
	 * Set attributes for an item in bulk
	 * Array has the property name as the keys
	 *
	 * @param array $data
	 * @return \{{ namespace }}\{{ modelname }}
	 */
	public function setAttributes($data) {
		foreach ($data as $key => $val) {
			if (\{{ namespace }}\{{ modelname }}::hasAttribute($key) && $this->{$key} !== $val) {
				$this->{$key} = $val;
			}
		}
		return $this;
	}

	/**
	 * Get list of date fields, used for timezone conversion
	 *
	 * @return array list of fields
	 */
	public function datefields() {
		return array(
{% for field in structure %}
{% if field.type == 'date' %}
			'{{ field.name }}' => array(
				'type' => 'date',
				'format' => 'Y-m-d',
				'timezone_mode' => '{{ field.timezone_mode }}',
				'timezone_comparison_mode' => '{{ field.timezone_comparison_mode }}',
			),
{% elseif field.type == 'dob' %}
			'{{ field.name }}' => array(
				'type' => 'dob',
				'format' => 'd/m/Y',
				'timezone_mode' => '{{ field.timezone_mode }}',
				'timezone_comparison_mode' => '{{ field.timezone_comparison_mode }}',
			),
{% elseif field.type == 'datetime' %}
			'{{ field.name }}' => array(
				'type' => 'datetime',
				'format' => 'Y-m-d H:i:s',
				'timezone_mode' => '{{ field.timezone_mode }}',
				'timezone_comparison_mode' => '{{ field.timezone_comparison_mode }}',
			),
{% elseif field.type == 'time' %}
			'{{ field.name }}' => array(
				'type' => 'time',
				'format' => 'H:i:s',
				'timezone_mode' => '{{ field.timezone_mode }}',
				'timezone_comparison_mode' => '{{ field.timezone_comparison_mode }}',
			),
{% endif %}
{% endfor %}
		);
	}

	public static function enum_options($field_name) {
{% for field in structure %}
{% if field.type == 'enum' %}
		if ($field_name == '{{ field.name }}') {
			$optx = explode(',', str_replace('&#039;', '', '{{ field.options }}'));
			return array_combine($optx, $optx);
		}

{% endif %}
{% endfor %}
		return array();
	}

	/**
	 * Should we delete this record for real or just flag as deleted?
	 * Uses the is_deleted field
	 *
	 * @return boolean
	 */
	public function fakeDelete() {
{% if deleteForReal %}
		return false;
{% else %}
		return true;
{% endif %}
	}

	/**
	 * Get the model names for the lookup
	 *
	 * @param string name of the variable
	 * @return string
	 */
	public static function refModel($varname) {
{% for field in belongsTo %}
		if ($varname == '{{field.varname}}') {
			return '\{{field.namespace}}\{{field.modelname}}';
		}
{% endfor %}
		return false;
	}

	/**
	 * Get the list of tags from the database comment
	 * @param string $field the field name
	 * @return string[] list of comment tags (_ prefixes)
	 */
	public function fieldTags($field) {
		$tags = array(
{% for field in structure %}
			'{{ field.name }}' => array(
{% for flag in field.comment_flags %}
				'{{ flag }}',
{% endfor %}
			),
{% endfor %}
		);
		if (!array_key_exists($field, $tags)) {
			return array();
		}
		return $tags[$field];
	}

	/**
	 * Get the human name of the field.
	 * @param string $field the field name
	 * @return string The field human name
	 */
	public function fieldHumanName($field) {
		$items = array(
{% for field in structure %}
			'{{ field.name }}' => '{{ field.displayname }}',
{% endfor %}
		);
		if (!array_key_exists($field, $items)) {
			return array();
		}
		return $items[$field];
	}

	/**
	 * Get the help text from the database comment.
	 * It is basically the comment minus the tags (_ prefixes)
	 * @param string $field the field name
	 * @return string The field comment
	 */
	public function fieldHelpText($field) {
		$items = array(
{% for field in structure %}
			'{{ field.name }}' => '{{ field.helptext }}',
{% endfor %}
		);
		if (!array_key_exists($field, $items)) {
			return array();
		}
		return $items[$field];
	}

	/**
	 * Get the fields for admin list
	 * @return string[] admin list fields
	 */
	public function adminFields() {
		return array(
{% set continue = false %}
{% set fieldcounter = 0 %}
{% for field in structure %}
{% if field.type == 'text' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'richtext' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'pagebuilder' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'formbuilder' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'html' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'css' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'js' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'json' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'jsonld' %}
{% set continue = true %}
{% endif %}
{% if field.type == 'serialize' %}
{% set continue = true %}
{% endif %}
{% if field.hidden_in_forms %}
{% set continue = true %}
{% endif %}
{% if continue %}
{% set continue = false %}
{% else %}
{% set fieldcounter = fieldcounter + 1 %}
{% if (fieldcounter < 7) or (field.name == 'sort_order' ) or (field.name == 'stealth') or (field.name == 'enabled') %}
			'{{field.name}}',
{% endif %}
{% endif %}
{% endfor %}
		);
	}

	/**
	 * Get the fields for edit forms
	 * @return string[] form fields
	 */
	public function formFields() {
		return array(
{% for field in structure %}
{% if field.hidden_in_forms == false %}
			'{{ field.name }}',
{% endif %}
{% endfor %}
		);
	}

	/**
	 * Get the field default value
	 * @param string $field
	 * @return integer
	 */
	public function fieldDefaultValue($field) {
		$items = array(
{% for field in structure %}
			'{{ field.name }}' => '{{ field.default_value }}',
{% endfor %}
		);
		if (!array_key_exists($field, $items)) {
			return 0;
		}
		return $items[$field];
	}

	/**
	 * Get the field max length
	 * @param string $field
	 * @return integer
	 */
	public function fieldLength($field) {
		$items = array(
{% for field in structure %}
			'{{ field.name }}' => {{ field.length }},
{% endfor %}
		);
		if (!array_key_exists($field, $items)) {
			return 0;
		}
		return $items[$field];
	}

	/**
	 * Get whether the field is required
	 * @param string $field
	 * @return boolean
	 */
	public function fieldIsRequired($field) {
		$items = array(
{% for field in structure %}
			'{{ field.name }}' => {{ field.required }},
{% endfor %}
		);
		if (!array_key_exists($field, $items)) {
			return false;
		}
		return $items[$field];
	}
}
